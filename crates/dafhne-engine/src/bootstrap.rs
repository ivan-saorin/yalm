//! Bootstrap Loop: Connector Enrichment from Generated Text (Phase 19)
//!
//! DAFHNE generates descriptions of its known concepts using `describe()`, feeds
//! the generated text back through connector discovery, and uses the enriched
//! connector set to produce a richer equilibrium. Grammar evolves without
//! changing any dictionary.

use std::collections::{HashMap, HashSet};

use dafhne_core::*;

use crate::multispace::MultiSpace;
use crate::resolver::describe;

// ─── Configuration ──────────────────────────────────────────

/// Configuration for the bootstrap loop.
pub struct BootstrapConfig {
    /// Maximum number of bootstrap iterations (default: 5).
    pub max_iterations: usize,
    /// Stop if fewer than this many new connectors are found (default: 1).
    pub min_new_connectors: usize,
    /// Which spaces generate describe() text and have connectors re-discovered.
    /// Default: ["content", "grammar"].
    pub describe_spaces: Vec<String>,
    /// Whether to print verbose output per level.
    pub verbose: bool,
}

impl Default for BootstrapConfig {
    fn default() -> Self {
        Self {
            max_iterations: 5,
            min_new_connectors: 1,
            describe_spaces: vec!["content".to_string(), "grammar".to_string()],
            verbose: true,
        }
    }
}

// ─── Results ────────────────────────────────────────────────

/// Result from the entire bootstrap loop.
pub struct BootstrapResult {
    /// Per-level results.
    pub levels: Vec<LevelResult>,
    /// The level at which convergence was reached (or max_iterations if not converged).
    pub converged_at: usize,
}

/// Result from a single bootstrap level.
pub struct LevelResult {
    /// Level number (1-indexed: Level 1 = first iteration after baseline).
    pub level: usize,
    /// New connector patterns found at this level: (space_name, pattern).
    pub new_connectors: Vec<(String, Vec<String>)>,
    /// Connector patterns lost at this level: (space_name, pattern).
    pub lost_connectors: Vec<(String, Vec<String>)>,
    /// Total number of sentences generated by describe() at this level.
    pub generated_sentences: usize,
    /// Per-space connector counts after this level.
    pub connector_counts: HashMap<String, usize>,
}

// ─── Bootstrap Implementation ───────────────────────────────

impl MultiSpace {
    /// Run the bootstrap loop: generate describe() text, re-discover connectors,
    /// rebuild geometry, repeat until convergence.
    ///
    /// For each participating space (e.g., "content", "grammar"):
    /// 1. Call `describe()` on every content word → collect sentences
    /// 2. Re-train the engine with dictionary + generated sentences
    /// 3. Diff connector sets: what's new, what's lost
    /// 4. If no new connectors found → convergence, stop
    pub fn bootstrap(&mut self, config: &BootstrapConfig) -> BootstrapResult {
        let mut levels: Vec<LevelResult> = Vec::new();

        for iteration in 0..config.max_iterations {
            let level_num = iteration + 1;

            if config.verbose {
                println!("\n=== Bootstrap Level {} ===", level_num);
            }

            let mut level_result = LevelResult {
                level: level_num,
                new_connectors: Vec::new(),
                lost_connectors: Vec::new(),
                generated_sentences: 0,
                connector_counts: HashMap::new(),
            };

            // ── Step 1: Generate describe() sentences for each participating space ──
            // We collect all generated sentences into owned data (immutable borrows only),
            // then release the borrows before Step 2 which needs mutable access.
            let mut per_space_sentences: HashMap<String, Vec<String>> = HashMap::new();

            for space_name in &config.describe_spaces {
                let space = match self.spaces.get(space_name) {
                    Some(s) => s,
                    None => continue,
                };

                let mut generated: Vec<String> = Vec::new();
                let content_words = space.engine.content();

                for entry in &space.dictionary.entries {
                    if !content_words.contains(&entry.word) {
                        continue; // skip structural words — they don't have meaningful descriptions
                    }
                    let desc = describe(
                        &entry.word,
                        space.engine.space(),
                        &space.dictionary,
                        space.engine.structural(),
                        content_words,
                        &space.params,
                        &space.strategy,
                    );
                    generated.extend(desc);
                }

                if config.verbose {
                    println!(
                        "  [{}] Generated {} sentences from describe()",
                        space_name,
                        generated.len()
                    );
                }
                level_result.generated_sentences += generated.len();
                per_space_sentences.insert(space_name.clone(), generated);
            }

            // ── Step 2: For each participating space, retrain with enriched sentences ──
            // Snapshot old patterns first (immutable), then retrain (mutable).
            for space_name in &config.describe_spaces {
                let extra_sentences = match per_space_sentences.get(space_name) {
                    Some(s) => s,
                    None => continue,
                };

                // Snapshot old connector patterns before retraining
                let old_patterns: HashSet<Vec<String>> = match self.spaces.get(space_name) {
                    Some(s) => s
                        .engine
                        .space()
                        .connectors
                        .iter()
                        .map(|c| c.pattern.clone())
                        .collect(),
                    None => continue,
                };
                let old_count = old_patterns.len();

                // Retrain with enriched sentences (mutable borrow)
                let space_mut = self.spaces.get_mut(space_name).unwrap();
                space_mut
                    .engine
                    .retrain_with_extra_sentences(extra_sentences);

                // Compute diff: new vs old connector patterns
                let new_patterns: HashSet<Vec<String>> = space_mut
                    .engine
                    .space()
                    .connectors
                    .iter()
                    .map(|c| c.pattern.clone())
                    .collect();

                let added: Vec<Vec<String>> =
                    new_patterns.difference(&old_patterns).cloned().collect();
                let removed: Vec<Vec<String>> =
                    old_patterns.difference(&new_patterns).cloned().collect();

                if config.verbose {
                    println!(
                        "  [{}] Connectors: {} -> {} (+{} -{})",
                        space_name,
                        old_count,
                        new_patterns.len(),
                        added.len(),
                        removed.len()
                    );
                    for p in &added {
                        println!("    + {:?}", p);
                    }
                    for p in &removed {
                        println!("    - {:?}", p);
                    }
                }

                for p in added {
                    level_result
                        .new_connectors
                        .push((space_name.clone(), p));
                }
                for p in removed {
                    level_result
                        .lost_connectors
                        .push((space_name.clone(), p));
                }
                level_result
                    .connector_counts
                    .insert(space_name.clone(), new_patterns.len());
            }

            // ── Step 3: Convergence check ──
            let total_new = level_result.new_connectors.len();

            if config.verbose {
                println!("  Total new connectors: {}", total_new);
            }

            let converged = total_new < config.min_new_connectors;
            levels.push(level_result);

            if converged {
                if config.verbose {
                    println!(
                        "  Converged at level {} (< {} new connectors)",
                        level_num, config.min_new_connectors
                    );
                }
                return BootstrapResult {
                    converged_at: level_num,
                    levels,
                };
            }
        }

        if config.verbose {
            println!(
                "\n  Reached max iterations ({})",
                config.max_iterations
            );
        }

        BootstrapResult {
            converged_at: config.max_iterations,
            levels,
        }
    }
}
